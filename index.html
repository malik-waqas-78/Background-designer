<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DeepSeek — Redesigned (single file)</title>
<style>
  :root{
    --bg:#071021;
    --panel:#071728;
    --muted:#9fb0c8;
    --accent:#4f8ef7;
    --card:rgba(255,255,255,0.02);
    --glass: rgba(255,255,255,0.03);
    color-scheme: dark;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:linear-gradient(180deg,var(--bg),#04101a); color:#e6f0fb}
  .app{display:grid;grid-template-columns:320px 1fr 420px;gap:16px;height:100vh;padding:18px;box-sizing:border-box}
  .panel{background:linear-gradient(180deg,var(--panel),#051827);border-radius:12px;padding:14px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
  h2{margin:0 0 12px;font-size:16px}
  h3{margin:0 0 8px;font-size:14px;color:var(--muted)}
  label{display:block;font-size:13px;color:var(--muted);margin:8px 0 6px}
  .row{display:flex;gap:8px;align-items:center}
  .col{display:flex;flex-direction:column;gap:8px}
  input[type=text], input[type=number], select, textarea{width:100%;padding:10px;border-radius:10px;border:none;background:var(--card);color:inherit;box-sizing:border-box;font-size:14px}
  button{padding:8px 10px;border-radius:10px;border:none;background:var(--accent);color:#072033;cursor:pointer;font-weight:600}
  .small{padding:6px 8px;font-size:13px;border-radius:8px}
  .muted{color:var(--muted);font-size:13px}
  .canvas-wrap{display:flex;align-items:center;justify-content:center}
  canvas#preview{background:#04121a;border-radius:12px;box-shadow:0 20px 50px rgba(0,0,0,0.6);width:620px;height:620px}
  .controls-card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.02)}
  .layers-list{display:flex;flex-direction:column;gap:10px;margin-top:10px}
  .layer-item{display:flex;gap:10px;align-items:center;padding:10px;border-radius:10px;background:var(--card);border:1px solid rgba(255,255,255,0.02);transition:box-shadow .15s, transform .08s}
  .layer-item .title{font-size:13px;font-weight:600}
  .layer-item .muted{font-size:12px;color:var(--muted)}
  .layer-item.selected{outline:2px solid rgba(79,142,247,0.18);box-shadow:0 6px 18px rgba(79,142,247,0.06);transform:translateY(-2px)}
  .layer-thumb{width:66px;height:46px;border-radius:6px;background:#071728;border:1px solid rgba(255,255,255,0.02);overflow:hidden;flex-shrink:0;display:flex;align-items:center;justify-content:center}
  .layer-info{flex:1;display:flex;flex-direction:column}
  .layer-controls{display:flex;gap:6px;align-items:center}
  input[type=range]{width:100%}
  .swatches{display:flex;gap:8px;flex-wrap:wrap}
  .swatch{width:36px;height:36px;border-radius:8px;border:2px solid rgba(0,0,0,0.35);cursor:pointer;box-shadow:inset 0 -6px 12px rgba(0,0,0,0.12)}
  .swatch .x{position:relative;top:-8px;left:8px;font-size:11px}
  .panel .footer{display:flex;gap:8px;justify-content:space-between;align-items:center;margin-top:12px}
  .label-row{display:flex;justify-content:space-between;align-items:center}
  .group-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
  .big-btn{padding:10px 12px;border-radius:10px;font-weight:700}
  .muted-ghost{color:rgba(230,238,247,0.7);font-size:12px}
  .control-row{display:flex;gap:8px;align-items:center}
  .thumb-preview{width:120px;height:120px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);overflow:hidden;background:#061525;display:flex;align-items:center;justify-content:center}
  .select-hint{font-size:12px;color:var(--muted);margin-top:6px}
  /* Make sliders easier to grab */
  input[type=range] { height: 28px; }
  /* responsive */
  @media (max-width: 1100px){
    .app{grid-template-columns:260px 1fr 340px}
    canvas#preview{width:520px;height:520px}
  }
  @media (max-width: 820px){
    .app{grid-template-columns:1fr;grid-auto-rows:min-content;padding:12px}
    canvas#preview{width:100%;height:auto}
  }
</style>
</head>
<body>
  <div class="app">
    <!-- LEFT: Background & Patterns -->
    <div class="panel">
      <h2>Background & Patterns</h2>

      <div class="controls-card">
        <label>Background mode</label>
        <select id="bgMode">
          <option value="solid">Solid</option>
          <option value="linear">Linear</option>
          <option value="radial">Radial</option>
        </select>

        <label>Background colors</label>
        <div class="swatches" id="bgSwatches"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input type="color" id="bgNewColor" value="#0b1220">
          <button id="bgAdd" class="small">Add</button>
        </div>

        <label style="margin-top:10px">Background opacity</label>
        <div class="control-row">
          <input id="bgOpacity" type="range" min="0" max="100" value="100">
          <div class="muted-ghost" id="bgOpacityVal">100%</div>
        </div>
      </div>

      <div style="height:12px"></div>

      <div class="controls-card">
        <label>Pattern quick pick</label>
        <div class="group-grid" id="patternButtons"></div>

        <label style="margin-top:8px">Pattern colors</label>
        <div class="swatches" id="patternSwatches"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input type="color" id="patternNewColor" value="#ffffff">
          <button id="patternAdd" class="small">Add</button>
        </div>

        <label style="margin-top:8px">Pattern defaults</label>
        <div class="control-row">
          <div style="flex:1">
            <label class="muted">thickness</label>
            <input id="patternThickness" type="range" min="0" max="80" value="2">
          </div>
          <div style="flex:1">
            <label class="muted">spacing</label>
            <input id="patternSpacing" type="range" min="2" max="300" value="40">
          </div>
        </div>

        <div class="control-row" style="margin-top:8px">
          <div style="flex:1">
            <label class="muted">size</label>
            <input id="patternSize" type="range" min="2" max="400" value="24">
          </div>
          <div style="flex:1">
            <label class="muted">rotate</label>
            <input id="patternRotate" type="range" min="0" max="360" value="0">
          </div>
        </div>

        <label style="margin-top:8px">pattern opacity (new layers)</label>
        <div class="control-row">
          <input id="patternDefaultOpacity" type="range" min="0" max="100" value="100">
          <div class="muted-ghost" id="patternDefaultOpacityVal">100%</div>
        </div>

      </div>

      <div style="height:12px"></div>

      <div class="controls-card">
        <label>Canvas (global)</label>
        <div class="group-grid">
          <div>
            <label class="muted">zoom</label>
            <input id="canvasZoom" type="range" min="10" max="300" value="100">
          </div>
          <div>
            <label class="muted">blur</label>
            <input id="canvasBlur" type="range" min="0" max="40" value="0">
          </div>
        </div>
        <div style="display:flex;gap:8px;margin-top:10px;justify-content:space-between">
          <button id="randomize" class="big-btn">Randomize</button>
          <div style="display:flex;gap:8px">
            <button id="undo" class="small">Undo</button>
            <button id="redo" class="small">Redo</button>
          </div>
        </div>

        <div style="margin-top:10px" class="select-hint">Tip: click a layer on the right to edit its properties. Thumbnails update live.</div>
      </div>
    </div>

    <!-- CENTER: Canvas -->
    <div class="canvas-wrap">
      <div style="display:flex;flex-direction:column;align-items:center;gap:10px">
        <div style="display:flex;gap:10px;align-items:center;width:100%;justify-content:center">
          <div class="muted">Preview</div>
          <div class="muted" id="sizeNote" style="font-size:13px">1080 × 1080</div>
        </div>
        <canvas id="preview" width="1080" height="1080"></canvas>
        <div style="display:flex;gap:8px">
          <button id="export" class="big-btn">Export PNG</button>
          <button id="reset" class="small">Reset</button>
        </div>
      </div>
    </div>

    <!-- RIGHT: Layers & Selected properties -->
    <div class="panel">
      <h2>Layers</h2>

      <div class="controls-card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="muted">Top → Bottom</div>
          <div style="display:flex;gap:8px">
            <button id="addPattern" class="small">+ Pattern</button>
            <button id="addText" class="small">+ Text</button>
            <button id="addImage" class="small">+ Image</button>
          </div>
        </div>

        <div class="layers-list" id="layersList" style="margin-top:12px"></div>
      </div>

      <div style="height:12px"></div>

      <div class="controls-card" id="selectedCard">
        <h3>Selected Layer</h3>
        <div id="noSelection" class="muted">No layer selected — add a layer or click one from the list.</div>

        <div id="selContent" style="display:none">
          <div style="display:flex;gap:12px;align-items:center;margin-bottom:10px">
            <div class="thumb-preview" id="selThumb"><canvas id="selThumbCanvas" width="240" height="240" style="width:100%;height:100%"></canvas></div>
            <div style="flex:1">
              <div style="display:flex;justify-content:space-between;align-items:center">
                <div><strong id="selTitle">Layer</strong><div class="muted-ghost" id="selType">type</div></div>
                <div style="display:flex;gap:8px;align-items:center">
                  <button id="dupLayer" class="small">Duplicate</button>
                  <button id="deleteLayer" class="small">Delete</button>
                </div>
              </div>
              <div style="margin-top:8px">
                <label>Visible</label>
                <input id="selVisible" type="checkbox" checked>
              </div>
            </div>
          </div>

          <label>Opacity</label>
          <div class="control-row">
            <input id="selOpacity" type="range" min="0" max="100" value="100">
            <div class="muted-ghost" id="selOpacityVal">100%</div>
          </div>

          <label style="margin-top:8px">Blend mode</label>
          <select id="selBlend">
            <option value="source-over">Normal</option>
            <option value="multiply">Multiply</option>
            <option value="screen">Screen</option>
            <option value="overlay">Overlay</option>
            <option value="lighten">Lighten</option>
            <option value="darken">Darken</option>
          </select>

          <div id="typeSpecific" style="margin-top:12px"></div>

          <div style="display:flex;gap:8px;margin-top:12px;justify-content:space-between">
            <div style="display:flex;gap:6px">
              <button id="moveUp" class="small">Move up</button>
              <button id="moveDown" class="small">Move down</button>
            </div>
            <div style="display:flex;gap:6px">
              <button id="applyChanges" class="small">Apply</button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

<script>
/* ======= State ======= */
const STATE = {
  canvasSize:1080,
  bg:{ mode:'solid', colors:['#071728'], opacity:1 },
  layers: [], // top-last stacking order (index 0 is bottom)
  selected:null,
  history:[],
  historyIndex:-1,
  patternDefaults:{
    thickness:2, spacing:40, size:24, rotation:0, colors:['#ffffff'], opacity:1
  },
  canvasZoom:1,
  canvasBlur:0
};

/* ======= DOM refs ======= */
const preview = document.getElementById('preview');
const pctx = preview.getContext('2d');

const bgSwatches = document.getElementById('bgSwatches');
const bgNewColor = document.getElementById('bgNewColor');
const bgAdd = document.getElementById('bgAdd');
const bgMode = document.getElementById('bgMode');
const bgOpacity = document.getElementById('bgOpacity');
const bgOpacityVal = document.getElementById('bgOpacityVal');

const patternButtons = document.getElementById('patternButtons');
const patternSwatches = document.getElementById('patternSwatches');
const patternNewColor = document.getElementById('patternNewColor');
const patternAdd = document.getElementById('patternAdd');
const patternThickness = document.getElementById('patternThickness');
const patternSpacing = document.getElementById('patternSpacing');
const patternSize = document.getElementById('patternSize');
const patternRotate = document.getElementById('patternRotate');
const patternDefaultOpacity = document.getElementById('patternDefaultOpacity');
const patternDefaultOpacityVal = document.getElementById('patternDefaultOpacityVal');

const canvasZoom = document.getElementById('canvasZoom');
const canvasBlur = document.getElementById('canvasBlur');

const randomizeBtn = document.getElementById('randomize');
const undoBtn = document.getElementById('undo');
const redoBtn = document.getElementById('redo');
const exportBtn = document.getElementById('export');
const resetBtn = document.getElementById('reset');

const layersList = document.getElementById('layersList');
const addPatternBtn = document.getElementById('addPattern');
const addTextBtn = document.getElementById('addText');
const addImageBtn = document.getElementById('addImage');

const selectedCard = document.getElementById('selectedCard');
const noSelection = document.getElementById('noSelection');
const selContent = document.getElementById('selContent');
const selTitle = document.getElementById('selTitle');
const selType = document.getElementById('selType');
const selThumbCanvas = document.getElementById('selThumbCanvas');
const selThumbCtx = selThumbCanvas.getContext('2d');
const selVisible = document.getElementById('selVisible');
const selOpacity = document.getElementById('selOpacity');
const selOpacityVal = document.getElementById('selOpacityVal');
const selBlend = document.getElementById('selBlend');
const moveUp = document.getElementById('moveUp');
const moveDown = document.getElementById('moveDown');
const applyChanges = document.getElementById('applyChanges');
const deleteLayerBtn = document.getElementById('deleteLayer');
const dupLayerBtn = document.getElementById('dupLayer');
const typeSpecific = document.getElementById('typeSpecific');

const addImageInput = document.createElement('input');
addImageInput.type = 'file';
addImageInput.accept = 'image/*';
addImageInput.style.display='none';
document.body.appendChild(addImageInput);

/* ======= Patterns list ======= */
const PATTERNS = ['grid','stripes','dots','noise','checkerboard','hexagons','lines','circles','diamonds','triangles'];

/* ======= Utilities ======= */
function uid(prefix='id'){return prefix+Math.random().toString(36).slice(2,9)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function hexToRgb(hex){ hex = (hex||'#000').replace('#',''); if(hex.length===3) hex = hex.split('').map(x=>x+x).join(''); return { r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16) } }
function rgba(hex,a=1){ const c=hexToRgb(hex); return `rgba(${c.r},${c.g},${c.b},${a})` }

/* ======= History ======= */
function pushHistory(skipRender=false){
  try{
    const snapshot = JSON.parse(JSON.stringify({
      bg:STATE.bg,
      layers:STATE.layers,
      canvasBlur:STATE.canvasBlur,
      canvasZoom:STATE.canvasZoom
    }));
    STATE.history = STATE.history.slice(0, STATE.historyIndex+1);
    STATE.history.push(snapshot);
    STATE.historyIndex = STATE.history.length-1;
    if(!skipRender) render();
  }catch(e){ console.warn('history push err',e) }
}
function undo(){ if(STATE.historyIndex<=0) return; STATE.historyIndex--; restore(STATE.history[STATE.historyIndex]); }
function redo(){ if(STATE.historyIndex>=STATE.history.length-1) return; STATE.historyIndex++; restore(STATE.history[STATE.historyIndex]); }
function restore(snap){
  STATE.bg = JSON.parse(JSON.stringify(snap.bg));
  STATE.layers = JSON.parse(JSON.stringify(snap.layers));
  STATE.canvasBlur = snap.canvasBlur;
  STATE.canvasZoom = snap.canvasZoom;
  refreshUI();
  render();
}

/* ======= Init UI ======= */
function initUI(){
  // patterns buttons
  PATTERNS.forEach(p=>{
    const b = document.createElement('button');
    b.className='small';
    b.textContent = p;
    b.onclick = ()=>{ pickPatternQuick(p); };
    patternButtons.appendChild(b);
  });

  // default swatches
  renderBgSwatches();
  renderPatternSwatches();

  // Events
  bgAdd.onclick = ()=>{ STATE.bg.colors.push(bgNewColor.value); renderBgSwatches(); pushHistory(); }
  bgMode.onchange = ()=>{ STATE.bg.mode = bgMode.value; pushHistory(); }
  bgOpacity.oninput = ()=>{ STATE.bg.opacity = bgOpacity.value/100; bgOpacityVal.textContent = bgOpacity.value+'%'; render(); pushHistory(); }
  bgOpacity.onchange = ()=> pushHistory();

  patternAdd.onclick = ()=>{ STATE.patternDefaults.colors.push(patternNewColor.value); renderPatternSwatches(); pushHistory(); }
  patternThickness.oninput = ()=>{ STATE.patternDefaults.thickness = +patternThickness.value; }
  patternThickness.onchange = ()=> pushHistory();
  patternSpacing.oninput = ()=>{ STATE.patternDefaults.spacing = +patternSpacing.value; }
  patternSpacing.onchange = ()=> pushHistory();
  patternSize.oninput = ()=>{ STATE.patternDefaults.size = +patternSize.value; }
  patternSize.onchange = ()=> pushHistory();
  patternRotate.oninput = ()=>{ STATE.patternDefaults.rotation = +patternRotate.value; }
  patternRotate.onchange = ()=> pushHistory();
  patternDefaultOpacity.oninput = ()=>{ STATE.patternDefaults.opacity = patternDefaultOpacity.value/100; patternDefaultOpacityVal.textContent = patternDefaultOpacity.value+'%'; }
  patternDefaultOpacity.onchange = ()=> pushHistory();

  canvasZoom.oninput = ()=>{ STATE.canvasZoom = +canvasZoom.value/100; render(); }
  canvasZoom.onchange = ()=> pushHistory();
  canvasBlur.oninput = ()=>{ STATE.canvasBlur = +canvasBlur.value; render(); }
  canvasBlur.onchange = ()=> pushHistory();

  randomizeBtn.onclick = randomizeDesign;
  undoBtn.onclick = undo;
  redoBtn.onclick = redo;
  exportBtn.onclick = exportPNG;
  resetBtn.onclick = resetDesign;

  addPatternBtn.onclick = ()=> addLayer(makePatternLayer());
  addTextBtn.onclick = ()=> addLayer(makeTextLayer('Text'));
  addImageBtn.onclick = ()=> fileImageInput();

  addImageInput.onchange = async(e)=>{
    const f = e.target.files[0];
    if(!f) return;
    const img = await loadImageFromFile(f);
    addLayer(makeImageLayer(img));
    addImageInput.value='';
  };

  // selected controls
  selVisible.onchange = ()=>{ const sel = findSelected(); if(sel){ sel.visible = selVisible.checked; render(); pushHistory(); }} ;
  selOpacity.oninput = ()=>{ const sel = findSelected(); if(sel){ sel.opacity = selOpacity.value/100; selOpacityVal.textContent = selOpacity.value+'%'; render(); }
  selOpacity.onchange = ()=> pushHistory(); };
  selBlend.onchange = ()=>{ const sel = findSelected(); if(sel){ sel.blend = selBlend.value; render(); pushHistory(); } };
  moveUp.onclick = ()=>{ if(STATE.selected) moveLayer(STATE.selected,-1); }
  moveDown.onclick = ()=>{ if(STATE.selected) moveLayer(STATE.selected,1); }
  applyChanges.onclick = ()=>{ pushHistory(); render(); }
  deleteLayerBtn.onclick = ()=>{ if(STATE.selected) { removeLayer(STATE.selected); } };
  dupLayerBtn.onclick = ()=>{ if(STATE.selected) duplicateLayer(STATE.selected); };

  // initial
  pushHistory(true);
  render();
}

/* ======= Layer constructors ======= */
function makePatternLayer(opts){
  const p = JSON.parse(JSON.stringify(STATE.patternDefaults));
  if(opts && opts.patternType) p.patternType = opts.patternType;
  return {
    id: uid('L'),
    type: 'pattern',
    visible:true,
    opacity: p.opacity ?? 1,
    blend:'source-over',
    params:{
      patternType: p.patternType || 'grid',
      colors: p.colors && p.colors.length? [...p.colors] : ['#ffffff'],
      thickness: p.thickness || 2,
      spacing: p.spacing || 40,
      size: p.size || 24,
      rotation: p.rotation || 0,
      opacity: p.opacity ?? 1
    }
  };
}
function makeTextLayer(text='Text'){
  return {
    id: uid('L'),
    type:'text',
    visible:true,
    opacity:1,
    blend:'source-over',
    text:text,
    x: STATE.canvasSize/2,
    y: STATE.canvasSize/2,
    fontSize:72,
    fontFamily:'Inter',
    color:'#ffffff',
    stroke:'#000000',
    strokeWidth: Math.round(72*0.06),
    align:'center',
    baseline:'middle',
    rotation:0,
    scale:1,
    bold:false,
    italic:false,
    letterSpacing:0,
    shadow:{ offsetX:0, offsetY:0, blur:0, color:'#000000' }
  };
}
function makeImageLayer(img){
  return {
    id: uid('L'),
    type:'image',
    visible:true,
    opacity:1,
    blend:'source-over',
    imgSrc: img.src,
    x: STATE.canvasSize/2,
    y: STATE.canvasSize/2,
    w: img.width,
    h: img.height,
    scale: Math.min(STATE.canvasSize/img.width, STATE.canvasSize/img.height)*0.6,
    rotation:0,
    flipX:false,
    flipY:false,
    filters:{ brightness:1, contrast:1, saturate:1, hue:0, blur:0 }
  };
}

/* ======= Layer operations ======= */
function addLayer(layer){
  STATE.layers.push(layer);
  STATE.selected = layer.id;
  renderLayers();
  syncSelectedUI();
  pushHistory();
}
function removeLayer(id){
  STATE.layers = STATE.layers.filter(l=>l.id!==id);
  if(STATE.selected === id) STATE.selected = STATE.layers.length?STATE.layers[STATE.layers.length-1].id : null;
  renderLayers();
  syncSelectedUI();
  pushHistory();
}
function duplicateLayer(id){
  const l = STATE.layers.find(x=>x.id===id);
  if(!l) return;
  const copy = JSON.parse(JSON.stringify(l));
  copy.id = uid('L');
  copy.x = (copy.x || STATE.canvasSize/2) + 20;
  copy.y = (copy.y || STATE.canvasSize/2) + 20;
  STATE.layers.push(copy);
  STATE.selected = copy.id;
  renderLayers();
  syncSelectedUI();
  pushHistory();
}
function moveLayer(id,dir){
  const i = STATE.layers.findIndex(l=>l.id===id);
  if(i<0) return;
  const j = clamp(i+dir,0,STATE.layers.length-1);
  const item = STATE.layers.splice(i,1)[0];
  STATE.layers.splice(j,0,item);
  renderLayers();
  pushHistory();
}
function findSelected(){ return STATE.layers.find(l=>l.id===STATE.selected) }

/* ======= Render Layers list + thumbnails ======= */
function renderLayers(){
  layersList.innerHTML='';
  // display top->bottom, so iterate reversed
  for(let i=STATE.layers.length-1;i>=0;i--){
    const layer = STATE.layers[i];
    const el = document.createElement('div');
    el.className='layer-item' + (STATE.selected===layer.id?' selected':'');
    // thumbnail canvas
    const thumb = document.createElement('div'); thumb.className='layer-thumb';
    const tcan = document.createElement('canvas'); tcan.width=220; tcan.height=140; tcan.style.width='100%'; tcan.style.height='100%';
    thumb.appendChild(tcan);
    el.appendChild(thumb);

    const info = document.createElement('div'); info.className='layer-info';
    const title = document.createElement('div'); title.className='title'; title.textContent = `${layer.type}${layer.type==='text'?` — ${String(layer.text).slice(0,18)}`:''}`;
    const meta = document.createElement('div'); meta.className='muted'; meta.textContent = `opacity ${Math.round((layer.opacity||1)*100)}% • blend ${layer.blend||'normal'}`;
    info.appendChild(title); info.appendChild(meta);
    el.appendChild(info);

    const controls = document.createElement('div'); controls.className='layer-controls';
    const selectBtn = document.createElement('button'); selectBtn.className='small'; selectBtn.textContent='Edit';
    selectBtn.onclick = ()=>{ STATE.selected = layer.id; renderLayers(); syncSelectedUI(); render(); };
    const up = document.createElement('button'); up.className='small'; up.textContent='▲'; up.onclick = (ev)=>{ ev.stopPropagation(); moveLayer(layer.id,-1) };
    const down = document.createElement('button'); down.className='small'; down.textContent='▼'; down.onclick = (ev)=>{ ev.stopPropagation(); moveLayer(layer.id,1) };
    const del = document.createElement('button'); del.className='small'; del.textContent='🗑'; del.onclick = (ev)=>{ ev.stopPropagation(); removeLayer(layer.id) };
    controls.appendChild(selectBtn); controls.appendChild(up); controls.appendChild(down); controls.appendChild(del);
    el.appendChild(controls);

    layersList.appendChild(el);

    // draw thumbnail
    drawLayerThumbnail(layer, tcan.getContext('2d'));
    // click on whole item selects
    el.onclick = ()=>{ STATE.selected = layer.id; renderLayers(); syncSelectedUI(); render(); };
  }
}

/* ======= Thumbnail rendering (small) ======= */
function drawLayerThumbnail(layer, ctx){
  const S = 220, H = 140;
  ctx.clearRect(0,0,S,H);
  ctx.save();
  // simple background
  ctx.fillStyle = '#061425';
  ctx.fillRect(0,0,S,H);
  ctx.globalAlpha = layer.opacity ?? 1;
  ctx.translate(S/2,H/2);
  ctx.scale( (S/STATE.canvasSize)*0.45, (H/STATE.canvasSize)*0.45 );
  ctx.translate(-STATE.canvasSize/2, -STATE.canvasSize/2);
  // draw layer content only
  if(!layer.visible){
    ctx.globalAlpha = 0.25;
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,STATE.canvasSize,STATE.canvasSize);
  }
  switch(layer.type){
    case 'pattern': drawPattern(ctx, layer.params); break;
    case 'text': drawText(ctx, layer, true); break;
    case 'image': drawImage(ctx, layer); break;
  }
  ctx.restore();
}

/* ======= Main render (hi canvas displayed in preview canvas scaled) ======= */
function render(){
  const W = STATE.canvasSize, H = STATE.canvasSize;
  // clear
  pctx.clearRect(0,0,preview.width, preview.height);
  // scaling for displayed preview
  const displaySize = preview.width;
  pctx.save();
  // draw into an internal offscreen canvas (hi-res) for accurate rendering
  const off = document.createElement('canvas'); off.width=W; off.height=H; const ctx = off.getContext('2d');
  // background
  drawBackground(ctx);
  // layers bottom -> top
  for(const layer of STATE.layers){
    if(!layer.visible) continue;
    ctx.save();
    ctx.globalCompositeOperation = layer.blend || 'source-over';
    ctx.globalAlpha = layer.opacity ?? 1;
    // apply canvas blur per-layer? we support global blur via filter
    ctx.filter = `blur(${STATE.canvasBlur}px)`;
    if(layer.type==='pattern') drawPattern(ctx, layer.params);
    else if(layer.type==='text') drawText(ctx, layer, false);
    else if(layer.type==='image') drawImage(ctx, layer);
    ctx.restore();
  }
  // scale to preview (apply zoom)
  const zoom = STATE.canvasZoom;
  const dest = preview;
  const destW = dest.width, destH = dest.height;
  pctx.imageSmoothingEnabled = true;
  
  // draw selection box if layer selected
  const sel = findSelected();
  if(sel && (sel.type==='text' || sel.type==='image')){
    ctx.save();
    ctx.strokeStyle = 'rgba(79,142,247,0.8)';
    ctx.lineWidth = 4;
    ctx.setLineDash([8,4]);
    ctx.translate(sel.x || W/2, sel.y || H/2);
    ctx.rotate((sel.rotation||0) * Math.PI/180);
    let boxW, boxH;
    if(sel.type==='text'){
      ctx.font = `${sel.bold ? '700':'400'} ${sel.fontSize||64}px ${sel.fontFamily||'Inter'}`;
      boxW = ctx.measureText(sel.text||'').width;
      boxH = sel.fontSize || 64;
    } else {
      boxW = sel.w;
      boxH = sel.h;
    }
    const scale = sel.scale || 1;
    ctx.strokeRect(-boxW/2*scale, -boxH/2*scale, boxW*scale, boxH*scale);
    ctx.restore();
  }
pctx.drawImage(off, 0,0,W,H, 0,0,destW,destH);
  pctx.restore();

  // update selected thumbnail
  updateSelectedThumb();
}

/* ======= Background drawing ======= */
function drawBackground(ctx){
  const W = STATE.canvasSize, H = STATE.canvasSize;
  if(STATE.bg.mode === 'solid' || STATE.bg.colors.length===1){
    ctx.fillStyle = rgba(STATE.bg.colors[0], STATE.bg.opacity);
    ctx.fillRect(0,0,W,H);
    return;
  }
  if(STATE.bg.mode === 'linear'){
    const g = ctx.createLinearGradient(0,0,W,H);
    const stops = STATE.bg.colors.length;
    STATE.bg.colors.forEach((c,i)=> g.addColorStop(i/(stops-1), rgba(c, STATE.bg.opacity)) );
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H); return;
  }
  if(STATE.bg.mode === 'radial'){
    const g = ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,Math.max(W,H)/2);
    const stops = STATE.bg.colors.length;
    STATE.bg.colors.forEach((c,i)=> g.addColorStop(i/(stops-1), rgba(c, STATE.bg.opacity)) );
    ctx.fillStyle = g; ctx.fillRect(0,0,W,H); return;
  }
}

/* ======= Patterns drawing ======= */
function drawPattern(ctx, p){
  p = p || {};
  const t = p.patternType || 'grid';
  ctx.save();
  ctx.translate(STATE.canvasSize/2, STATE.canvasSize/2);
  ctx.rotate((p.rotation||0)*Math.PI/180);
  ctx.translate(-STATE.canvasSize/2, -STATE.canvasSize/2);
  ctx.globalAlpha = p.opacity ?? 1;
  switch(t){
    case 'grid': patternGrid(ctx,p); break;
    case 'stripes': patternStripes(ctx,p); break;
    case 'dots': patternDots(ctx,p); break;
    case 'checkerboard': patternChecker(ctx,p); break;
    case 'hexagons': patternHex(ctx,p); break;
    case 'lines': patternLines(ctx,p); break;
    case 'circles': patternCircles(ctx,p); break;
    case 'diamonds': patternDiamonds(ctx,p); break;
    case 'triangles': patternTriangles(ctx,p); break;
    case 'noise': patternNoise(ctx,p); break;
    default: patternGrid(ctx,p); break;
  }
  ctx.restore();
}
function patternGrid(ctx,p){
  ctx.strokeStyle = p.colors && p.colors[0] ? p.colors[0] : '#ffffff';
  ctx.lineWidth = p.thickness || 1;
  for(let x=0;x<=STATE.canvasSize;x+=p.spacing||40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,STATE.canvasSize); ctx.stroke(); }
  for(let y=0;y<=STATE.canvasSize;y+=p.spacing||40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(STATE.canvasSize,y); ctx.stroke(); }
}
function patternStripes(ctx,p){
  const w = p.size || 40;
  for(let x=0;x<STATE.canvasSize;x+=w+(p.spacing||10)){
    const idx = Math.floor(x/(w+(p.spacing||10))) % (p.colors.length || 1);
    ctx.fillStyle = p.colors[idx] || '#fff';
    ctx.fillRect(x,0,w,STATE.canvasSize);
  }
}
function patternDots(ctx,p){
  const gap = p.spacing || 40; const r = (p.size||12)/2;
  for(let y=0;y<STATE.canvasSize;y+=gap) for(let x=0;x<STATE.canvasSize;x+=gap){
    const idx = Math.floor((x+y)/gap) % (p.colors.length||1);
    ctx.beginPath(); ctx.fillStyle = p.colors[idx]||'#fff'; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
}
function patternChecker(ctx,p){
  const s = p.size || 40;
  for(let y=0;y<STATE.canvasSize;y+=s) for(let x=0;x<STATE.canvasSize;x+=s){
    const idx = ((x/s|0)+(y/s|0)) % (p.colors.length || 1);
    ctx.fillStyle = p.colors[idx] || '#fff';
    ctx.fillRect(x,y,s,s);
  }
}
function patternHex(ctx,p){
  const s = p.size || 30; const gap = p.spacing || s*1.2;
  const h = Math.sqrt(3)/2*s;
  for(let y=0;y<STATE.canvasSize+h;y+=h+(gap/4)){
    for(let x=0;x<STATE.canvasSize+s;x+=s*0.75+(gap/4)){
      drawHex(ctx,x,y,s,p.colors[(x+y) % (p.colors.length||1)]);
    }
  }
}
function drawHex(ctx,x,y,s,color){ const a = Math.PI/3; ctx.beginPath(); for(let i=0;i<6;i++){ ctx.lineTo(x+Math.cos(a*i)*s, y+Math.sin(a*i)*s)} ctx.closePath(); ctx.fillStyle=color||'#fff'; ctx.fill(); }
function patternLines(ctx,p){
  ctx.strokeStyle = (p.colors && p.colors[0]) || '#fff';
  ctx.lineWidth = p.thickness||2;
  for(let y=0;y<STATE.canvasSize;y+=p.spacing||20){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(STATE.canvasSize,y); ctx.stroke(); }
}
function patternCircles(ctx,p){
  const gap = p.spacing || 40; const r = (p.size||20)/2;
  for(let y=0;y<STATE.canvasSize;y+=gap) for(let x=0;x<STATE.canvasSize;x+=gap){
    ctx.beginPath(); ctx.fillStyle = p.colors[((x+y)/gap|0) % (p.colors.length||1)]; ctx.arc(x+gap/2,y+gap/2,r,0,Math.PI*2); ctx.fill();
  }
}
function patternDiamonds(ctx,p){
  const gap = p.spacing || 40; const s = p.size || 20;
  for(let y=0;y<STATE.canvasSize;y+=gap) for(let x=0;x<STATE.canvasSize;x+=gap){
    const cx = x+gap/2, cy=y+gap/2; ctx.beginPath(); ctx.moveTo(cx,cy-s/2); ctx.lineTo(cx+s/2,cy); ctx.lineTo(cx,cy+s/2); ctx.lineTo(cx-s/2,cy); ctx.closePath();
    ctx.fillStyle = p.colors[((x+y)/gap|0) % (p.colors.length||1)]; ctx.fill();
  }
}
function patternTriangles(ctx,p){
  const gap = p.spacing || 40; const s = p.size || 30;
  for(let y=0;y<STATE.canvasSize;y+=gap) for(let x=0;x<STATE.canvasSize;x+=gap){
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+s,y); ctx.lineTo(x+s/2,y+s); ctx.closePath();
    ctx.fillStyle = p.colors[((x+y)/gap|0) % (p.colors.length||1)]; ctx.fill();
  }
}
function patternNoise(ctx,p){
  // colorful noise: using p.colors to tint random pixels
  const W = STATE.canvasSize, H = STATE.canvasSize;
  const img = ctx.createImageData(W,H);
  const cols = (p.colors && p.colors.length) ? p.colors.map(c=>hexToRgb(c)) : [{r:255,g:255,b:255}];
  for(let i=0;i<img.data.length;i+=4){
    const col = cols[Math.floor(Math.random()*cols.length)];
    const v = Math.floor(Math.random()*255);
    img.data[i]   = Math.floor((v + col.r)/2);
    img.data[i+1] = Math.floor((v + col.g)/2);
    img.data[i+2] = Math.floor((v + col.b)/2);
    img.data[i+3] = Math.floor(255 * (p.opacity ?? 1));
  }
  ctx.putImageData(img,0,0);
}

/* ======= Text drawing ======= */
function drawText(ctx, layer, isThumb=false){
  ctx.save();
  ctx.translate(layer.x||STATE.canvasSize/2, layer.y||STATE.canvasSize/2);
  ctx.rotate((layer.rotation||0)*Math.PI/180);
  ctx.scale(layer.scale||1, layer.scale||1);
  const weight = layer.bold ? '700' : '400';
  const style = layer.italic ? 'italic' : 'normal';
  ctx.font = `${style} ${weight} ${layer.fontSize||64}px ${layer.fontFamily||'Inter'}`;
  ctx.textAlign = layer.align || 'center';
  ctx.textBaseline = layer.baseline || 'middle';
  if(layer.shadow && (layer.shadow.blur || layer.shadow.offsetX || layer.shadow.offsetY)){
    ctx.shadowOffsetX = layer.shadow.offsetX||0;
    ctx.shadowOffsetY = layer.shadow.offsetY||0;
    ctx.shadowBlur = layer.shadow.blur||0;
    ctx.shadowColor = layer.shadow.color || 'rgba(0,0,0,0.6)';
  } else { ctx.shadowColor = 'transparent'; }
  if(layer.stroke){
    ctx.lineWidth = layer.strokeWidth || Math.max(1, (layer.fontSize||64)*0.06);
    ctx.strokeStyle = layer.stroke;
    ctx.strokeText(layer.text||'', 0,0);
  }
  ctx.fillStyle = layer.color || '#fff';
  ctx.fillText(layer.text||'',0,0);

  // letter spacing (simple)
  if(layer.letterSpacing && layer.letterSpacing !== 0){
    const s = String(layer.text || '');
    // We'll render each char manually centered
    ctx.clearRect(-99999,-99999,1,1); // no-op to keep ctx state
    ctx.save();
    ctx.font = `${style} ${weight} ${layer.fontSize||64}px ${layer.fontFamily||'Inter'}`;
    let totalWidth = 0; const widths = [];
    for(const ch of s){ const w = ctx.measureText(ch).width; widths.push(w); totalWidth += w + layer.letterSpacing; }
    let start = -totalWidth/2;
    for(let i=0;i<s.length;i++){
      const ch = s[i];
      if(layer.stroke){ ctx.lineWidth = layer.strokeWidth || Math.max(1,(layer.fontSize||64)*0.06); ctx.strokeStyle = layer.stroke; ctx.strokeText(ch, start + widths[i]/2, 0); }
      ctx.fillText(ch, start + widths[i]/2, 0);
      start += widths[i] + layer.letterSpacing;
    }
    ctx.restore();
  }

  ctx.restore();
}

/* ======= Image drawing with simple filters using ctx.filter ======= */
const imageCache = {};
function loadImage(src){ return new Promise((res,rej)=>{ if(imageCache[src]) return res(imageCache[src]); const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>{ imageCache[src]=i; res(i) }; i.onerror=()=>rej(); i.src = src; }) }
function loadImageFromFile(file){ return new Promise((res,rej)=>{ const fr=new FileReader(); fr.onload = ()=>{ const img = new Image(); img.onload = ()=>res(img); img.src = fr.result; }; fr.readAsDataURL(file); }) }
function drawImage(ctx, layer){
  const img = imageCache[layer.imgSrc];
  if(!img){
    // attempt to load sync; if not loaded, start load and return (render will rerun)
    loadImage(layer.imgSrc).then(()=>{ render(); renderLayers(); }).catch(()=>{});
    return;
  }
  ctx.save();
  ctx.translate(layer.x||STATE.canvasSize/2, layer.y||STATE.canvasSize/2);
  ctx.rotate((layer.rotation||0)*Math.PI/180);
  const s = layer.scale || 1;
  ctx.scale(layer.flipX?-s:s, layer.flipY?-s:s);
  // apply filters
  const f = layer.filters || {};
  // ctx.filter supports brightness(), contrast(), saturate(), hue-rotate(), blur()
  const filterStr = `brightness(${f.brightness||1}) contrast(${f.contrast||1}) saturate(${f.saturate||1}) hue-rotate(${(f.hue||0)}deg) blur(${(f.blur||0)}px)`;
  ctx.filter = filterStr;
  ctx.drawImage(img, -layer.w/2, -layer.h/2, layer.w, layer.h);
  ctx.filter = 'none';
  ctx.restore();
}

/* ======= Thumbnails & Selected preview update ======= */
function updateSelectedThumb(){
  if(!STATE.selected){ selContent.style.display='none'; noSelection.style.display='block'; return; }
  const sel = findSelected();
  if(!sel) { selContent.style.display='none'; noSelection.style.display='block'; return; }
  noSelection.style.display='none';
  selContent.style.display='block';
  selTitle.textContent = (sel.type==='text' ? `Text — "${String(sel.text||'').slice(0,20)}"` : sel.type==='image'? 'Image' : 'Pattern');
  selType.textContent = sel.id;
  selVisible.checked = !!sel.visible;
  selOpacity.value = Math.round((sel.opacity||1)*100);
  selOpacityVal.textContent = selOpacity.value + '%';
  selBlend.value = sel.blend || 'source-over';
  // draw preview thumbnail at higher resolution
  const c = selThumbCanvas; const ctx = selThumbCtx;
  ctx.clearRect(0,0,c.width,c.height);
  ctx.save();
  // fill background
  ctx.fillStyle = '#061425'; ctx.fillRect(0,0,c.width,c.height);
  // draw selected layer centered with scale
  ctx.translate(c.width/2, c.height/2);
  ctx.scale( (c.width/STATE.canvasSize)*0.6, (c.height/STATE.canvasSize)*0.6 );
  ctx.translate(-STATE.canvasSize/2, -STATE.canvasSize/2);
  ctx.globalAlpha = sel.opacity ?? 1;
  if(sel.type === 'pattern') drawPattern(ctx, sel.params);
  else if(sel.type === 'text') drawText(ctx, sel, false);
  else if(sel.type === 'image') drawImage(ctx, sel);
  ctx.restore();

  // populate type specific controls area
  populateTypeSpecific(sel);
}

/* ======= Type specific UI population & binding ======= */
function clearElem(el){ while(el.firstChild) el.removeChild(el.firstChild); }
function populateTypeSpecific(sel){
  clearElem(typeSpecific);
  if(!sel) return;
  if(sel.type === 'pattern'){
    // pattern controls: patternType, colors, thickness, spacing, size, rotation, opacity
    const p = sel.params;
    const label = document.createElement('label'); label.textContent = 'Pattern type';
    const select = document.createElement('select');
    PATTERNS.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; if(k===p.patternType) o.selected=true; select.appendChild(o); });
    select.onchange = ()=>{ p.patternType = select.value; render(); renderLayers(); pushHistory(); };
    typeSpecific.appendChild(label); typeSpecific.appendChild(select);

    // colors
    const cl = document.createElement('div'); cl.className='swatches'; cl.style.marginTop='8px';
    (p.colors||[]).forEach((c,i)=>{
      const s = document.createElement('div'); s.className='swatch'; s.style.background=c;
      s.onclick = ()=>{ const v = prompt('Edit color hex', c) || c; p.colors[i]=v; render(); renderLayers(); pushHistory(); };
      const rx = document.createElement('div'); rx.className='x'; rx.textContent='✕'; rx.onclick = (ev)=>{ ev.stopPropagation(); p.colors.splice(i,1); render(); renderLayers(); pushHistory(); };
      s.appendChild(rx); cl.appendChild(s);
    });
    const add = document.createElement('button'); add.className='small'; add.textContent='+'; add.onclick = ()=>{ p.colors.push('#ffffff'); render(); renderLayers(); pushHistory(); };
    cl.appendChild(add);
    typeSpecific.appendChild(cl);

    // opacity
    const labOp = document.createElement('label'); labOp.textContent='Pattern opacity';
    const opRange = document.createElement('input'); opRange.type='range'; opRange.min=0; opRange.max=100; opRange.value=Math.round((p.opacity||1)*100);
    const opVal = document.createElement('div'); opVal.className='muted-ghost'; opVal.style.marginLeft='8px'; opVal.textContent = opRange.value+'%';
    opRange.oninput = ()=>{ p.opacity = opRange.value/100; opVal.textContent = opRange.value+'%'; render(); renderLayers(); };
    opRange.onchange = ()=> pushHistory();
    typeSpecific.appendChild(labOp);
    typeSpecific.appendChild(opRange);
    typeSpecific.appendChild(opVal);

    // thickness/spacing/size/rotation
    const tRow = document.createElement('div'); tRow.style.display='grid'; tRow.style.gridTemplateColumns='repeat(2,1fr)'; tRow.style.gap='8px'; tRow.style.marginTop='8px';
    const inTh = document.createElement('input'); inTh.type='range'; inTh.min=0; inTh.max=80; inTh.value=p.thickness||2; inTh.oninput = ()=>{ p.thickness = +inTh.value; render(); renderLayers(); }; inTh.onchange = ()=> pushHistory();
    const inSp = document.createElement('input'); inSp.type='range'; inSp.min=2; inSp.max=300; inSp.value=p.spacing||40; inSp.oninput = ()=>{ p.spacing = +inSp.value; render(); renderLayers(); }; inSp.onchange = ()=> pushHistory();
    tRow.appendChild(inTh); tRow.appendChild(inSp);
    typeSpecific.appendChild(tRow);
    const tRow2 = document.createElement('div'); tRow2.style.display='grid'; tRow2.style.gridTemplateColumns='repeat(2,1fr)'; tRow2.style.gap='8px'; tRow2.style.marginTop='8px';
    const inSize = document.createElement('input'); inSize.type='range'; inSize.min=2; inSize.max=400; inSize.value=p.size||24; inSize.oninput = ()=>{ p.size = +inSize.value; render(); renderLayers(); }; inSize.onchange = ()=> pushHistory();
    const inRot = document.createElement('input'); inRot.type='range'; inRot.min=0; inRot.max=360; inRot.value=p.rotation||0; inRot.oninput = ()=>{ p.rotation = +inRot.value; render(); renderLayers(); }; inRot.onchange = ()=> pushHistory();
    tRow2.appendChild(inSize); tRow2.appendChild(inRot);
    typeSpecific.appendChild(tRow2);

  } else if(sel.type === 'text'){
    // text controls: content, font, size, color, stroke, strokeWidth, letterSpacing, alignment, shadow, x,y
    const t1 = document.createElement('label'); t1.textContent = 'Text';
    const inpText = document.createElement('input'); inpText.type='text'; inpText.value = sel.text || '';
    inpText.oninput = ()=>{ sel.text = inpText.value; render(); renderLayers(); };
    inpText.onchange = ()=> pushHistory();
    typeSpecific.appendChild(t1); typeSpecific.appendChild(inpText);

    const grid = document.createElement('div'); grid.className='group-grid'; grid.style.marginTop='8px';
    const sizeWrap = document.createElement('div'); sizeWrap.innerHTML = '<label class="muted">Font size</label>';
    const sizeRange = document.createElement('input'); sizeRange.type='range'; sizeRange.min=6; sizeRange.max=300; sizeRange.value=sel.fontSize||72;
    sizeRange.oninput = ()=>{ sel.fontSize = +sizeRange.value; render(); renderLayers(); }; sizeRange.onchange = ()=> pushHistory();
    sizeWrap.appendChild(sizeRange);
    const fontWrap = document.createElement('div'); fontWrap.innerHTML = '<label class="muted">Font family</label>';
    const fontSel = document.createElement('select'); ['Inter','Arial','Times New Roman','Georgia','Courier New'].forEach(f=>{ const o=document.createElement('option'); o.value=f; o.textContent=f; if(f===sel.fontFamily) o.selected=true; fontSel.appendChild(o); });
    fontSel.onchange = ()=>{ sel.fontFamily = fontSel.value; render(); renderLayers(); pushHistory(); };
    fontWrap.appendChild(fontSel);
    grid.appendChild(sizeWrap); grid.appendChild(fontWrap);
    typeSpecific.appendChild(grid);

    const colorsRow = document.createElement('div'); colorsRow.style.display='flex'; colorsRow.style.gap='8px'; colorsRow.style.marginTop='8px';
    const inpColor = document.createElement('input'); inpColor.type='color'; inpColor.value = sel.color||'#ffffff'; inpColor.oninput = ()=>{ sel.color = inpColor.value; render(); renderLayers(); }; inpColor.onchange = ()=> pushHistory();
    const inpStroke = document.createElement('input'); inpStroke.type='color'; inpStroke.value = sel.stroke||'#000000'; inpStroke.oninput = ()=>{ sel.stroke = inpStroke.value; render(); renderLayers(); }; inpStroke.onchange = ()=> pushHistory();
    const strokeW = document.createElement('input'); strokeW.type='number'; strokeW.value = sel.strokeWidth||Math.round((sel.fontSize||72)*0.06); strokeW.style.width='80px'; strokeW.oninput = ()=>{ sel.strokeWidth = +strokeW.value; render(); renderLayers(); }; strokeW.onchange = ()=> pushHistory();
    colorsRow.appendChild(inpColor); colorsRow.appendChild(inpStroke); colorsRow.appendChild(strokeW);
    typeSpecific.appendChild(colorsRow);

    const moreRow = document.createElement('div'); moreRow.style.display='grid'; moreRow.style.gridTemplateColumns='repeat(2,1fr)'; moreRow.style.gap='8px'; moreRow.style.marginTop='8px';
    const letter = document.createElement('input'); letter.type='number'; letter.value = sel.letterSpacing||0; letter.oninput = ()=>{ sel.letterSpacing = +letter.value; render(); renderLayers(); }; letter.onchange = ()=> pushHistory();
    const align = document.createElement('select'); ['left','center','right'].forEach(a=>{ const o=document.createElement('option'); o.value=a; o.textContent=a; if(a===sel.align) o.selected=true; align.appendChild(o); }); align.onchange = ()=>{ sel.align = align.value; render(); renderLayers(); pushHistory(); };
    moreRow.appendChild(letter); moreRow.appendChild(align);
    typeSpecific.appendChild(document.createElement('label')).textContent = 'Letter spacing / Align';
    typeSpecific.appendChild(moreRow);

    // shadow controls
    const shLabel = document.createElement('label'); shLabel.textContent='Shadow (x,y,blur,color)';
    const shRow = document.createElement('div'); shRow.style.display='flex'; shRow.style.gap='6px'; shRow.style.marginTop='6px';
    const sx = document.createElement('input'); sx.type='number'; sx.value = sel.shadow?.offsetX||0; sx.style.width='60px'; sx.oninput = ()=>{ sel.shadow.offsetX = +sx.value; render(); renderLayers(); };
    const sy = document.createElement('input'); sy.type='number'; sy.value = sel.shadow?.offsetY||0; sy.style.width='60px'; sy.oninput = ()=>{ sel.shadow.offsetY = +sy.value; render(); renderLayers(); };
    const sblur = document.createElement('input'); sblur.type='number'; sblur.value = sel.shadow?.blur||0; sblur.style.width='60px'; sblur.oninput = ()=>{ sel.shadow.blur = +sblur.value; render(); renderLayers(); };
    const scol = document.createElement('input'); scol.type='color'; scol.value = sel.shadow?.color||'#000000'; scol.oninput = ()=>{ sel.shadow.color = scol.value; render(); renderLayers(); };
    shRow.appendChild(sx); shRow.appendChild(sy); shRow.appendChild(sblur); shRow.appendChild(scol);
    typeSpecific.appendChild(shLabel); typeSpecific.appendChild(shRow);

    // x/y
    const posRow = document.createElement('div'); posRow.style.display='grid'; posRow.style.gridTemplateColumns='repeat(2,1fr)'; posRow.style.gap='8px'; posRow.style.marginTop='8px';
    const px = document.createElement('input'); px.type='number'; px.value = Math.round(sel.x||STATE.canvasSize/2); px.oninput = ()=>{ sel.x = +px.value; render(); renderLayers(); }; px.onchange = ()=> pushHistory();
    const py = document.createElement('input'); py.type='number'; py.value = Math.round(sel.y||STATE.canvasSize/2); py.oninput = ()=>{ sel.y = +py.value; render(); renderLayers(); }; py.onchange = ()=> pushHistory();
    posRow.appendChild(px); posRow.appendChild(py);
    typeSpecific.appendChild(document.createElement('label')).textContent = 'Position X / Y';
    typeSpecific.appendChild(posRow);

  } else if(sel.type === 'image'){
    // image controls: flip, scale, rotate, brightness, contrast, saturate, hue, blur
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='8px'; row.style.marginTop='8px';
    const flipX = document.createElement('label'); flipX.innerHTML = '<input type="checkbox"> Flip X';
    const flipY = document.createElement('label'); flipY.innerHTML = '<input type="checkbox"> Flip Y';
    flipX.querySelector('input').checked = !!sel.flipX; flipY.querySelector('input').checked = !!sel.flipY;
    flipX.querySelector('input').onchange = ()=>{ sel.flipX = flipX.querySelector('input').checked; render(); renderLayers(); pushHistory(); };
    flipY.querySelector('input').onchange = ()=>{ sel.flipY = flipY.querySelector('input').checked; render(); renderLayers(); pushHistory(); };
    row.appendChild(flipX); row.appendChild(flipY);
    typeSpecific.appendChild(row);

    // scale and rotate
    const grid = document.createElement('div'); grid.className='group-grid'; grid.style.marginTop='8px';
    const sWrap = document.createElement('div'); sWrap.innerHTML='<label class="muted">Scale</label>';
    const sRange = document.createElement('input'); sRange.type='range'; sRange.min=0.05; sRange.max=3; sRange.step=0.01; sRange.value = sel.scale || 1;
    sRange.oninput = ()=>{ sel.scale = +sRange.value; render(); renderLayers(); }; sRange.onchange = ()=> pushHistory();
    sWrap.appendChild(sRange);

    const rWrap = document.createElement('div'); rWrap.innerHTML='<label class="muted">Rotate</label>';
    const rRange = document.createElement('input'); rRange.type='range'; rRange.min=0; rRange.max=360; rRange.value = sel.rotation||0;
    rRange.oninput = ()=>{ sel.rotation = +rRange.value; render(); renderLayers(); }; rRange.onchange = ()=> pushHistory();
    rWrap.appendChild(rRange);
    grid.appendChild(sWrap); grid.appendChild(rWrap);
    typeSpecific.appendChild(grid);

    // filters
    const flabel = document.createElement('label'); flabel.textContent = 'Image adjustments';
    typeSpecific.appendChild(flabel);
    const fGrid = document.createElement('div'); fGrid.className='group-grid'; fGrid.style.marginTop='8px';
    // brightness
    const bwrap = document.createElement('div'); bwrap.innerHTML = '<label class="muted">Brightness</label>';
    const bright = document.createElement('input'); bright.type='range'; bright.min=0; bright.max=3; bright.step=0.01; bright.value = sel.filters.brightness || 1;
    bright.oninput = ()=>{ sel.filters.brightness = +bright.value; render(); renderLayers(); }; bright.onchange = ()=> pushHistory();
    bwrap.appendChild(bright);
    // contrast
    const cwrap = document.createElement('div'); cwrap.innerHTML = '<label class="muted">Contrast</label>';
    const cont = document.createElement('input'); cont.type='range'; cont.min=0; cont.max=3; cont.step=0.01; cont.value = sel.filters.contrast || 1;
    cont.oninput = ()=>{ sel.filters.contrast = +cont.value; render(); renderLayers(); }; cont.onchange = ()=> pushHistory();
    cwrap.appendChild(cont);
    // saturate
    const swrap = document.createElement('div'); swrap.innerHTML = '<label class="muted">Saturation</label>';
    const sat = document.createElement('input'); sat.type='range'; sat.min=0; sat.max=3; sat.step=0.01; sat.value = sel.filters.saturate || 1;
    sat.oninput = ()=>{ sel.filters.saturate = +sat.value; render(); renderLayers(); }; sat.onchange = ()=> pushHistory();
    swrap.appendChild(sat);
    // hue
    const huw = document.createElement('div'); huw.innerHTML = '<label class="muted">Hue</label>';
    const hue = document.createElement('input'); hue.type='range'; hue.min=0; hue.max=360; hue.value = sel.filters.hue || 0;
    hue.oninput = ()=>{ sel.filters.hue = +hue.value; render(); renderLayers(); }; hue.onchange = ()=> pushHistory();
    huw.appendChild(hue);
    // blur
    const blw = document.createElement('div'); blw.innerHTML = '<label class="muted">Blur</label>';
    const bl = document.createElement('input'); bl.type='range'; bl.min=0; bl.max=40; bl.value = sel.filters.blur || 0;
    bl.oninput = ()=>{ sel.filters.blur = +bl.value; render(); renderLayers(); }; bl.onchange = ()=> pushHistory();
    blw.appendChild(bl);

    fGrid.appendChild(bwrap); fGrid.appendChild(cwrap); fGrid.appendChild(swrap); fGrid.appendChild(huw);
    typeSpecific.appendChild(fGrid);
    typeSpecific.appendChild(blw);

    // position
    const posRow = document.createElement('div'); posRow.style.display='grid'; posRow.style.gridTemplateColumns='repeat(2,1fr)'; posRow.style.gap='8px'; posRow.style.marginTop='8px';
    const px = document.createElement('input'); px.type='number'; px.value = Math.round(sel.x||STATE.canvasSize/2); px.oninput = ()=>{ sel.x = +px.value; render(); renderLayers(); }; px.onchange = ()=> pushHistory();
    const py = document.createElement('input'); py.type='number'; py.value = Math.round(sel.y||STATE.canvasSize/2); py.oninput = ()=>{ sel.y = +py.value; render(); renderLayers(); }; py.onchange = ()=> pushHistory();
    posRow.appendChild(px); posRow.appendChild(py);
    typeSpecific.appendChild(document.createElement('label')).textContent = 'Position X / Y';
    typeSpecific.appendChild(posRow);
  }
}

/* ======= Thumbnail for the right-hand layer items is already drawn in drawLayerThumbnail ======= */

/* ======= Sync UI to selection ======= */
function syncSelectedUI(){
  if(!STATE.selected){ noSelection.style.display='block'; selContent.style.display='none'; return; }
  const sel = findSelected();
  if(!sel){ noSelection.style.display='block'; selContent.style.display='none'; return; }
  noSelection.style.display='none'; selContent.style.display='block';
  selVisible.checked = !!sel.visible;
  selOpacity.value = Math.round((sel.opacity||1)*100);
  selOpacityVal.textContent = selOpacity.value+'%';
  selBlend.value = sel.blend || 'source-over';
  populateTypeSpecific(sel);
  // highlight in layers list — renderLayers will set class
  renderLayers();
}

/* ======= Misc UI rendering helpers ======= */
function renderBgSwatches(){
  bgSwatches.innerHTML='';
  STATE.bg.colors.forEach((c,idx)=>{
    const s = document.createElement('div'); s.className='swatch'; s.style.background = c;
    const x = document.createElement('div'); x.className='x'; x.textContent='✕';
    x.onclick = (ev)=>{ ev.stopPropagation(); STATE.bg.colors.splice(idx,1); renderBgSwatches(); pushHistory(); render(); };
    s.appendChild(x);
    s.onclick = ()=>{ const v = prompt('Edit color hex', c) || c; STATE.bg.colors[idx] = v; renderBgSwatches(); pushHistory(); render(); };
    bgSwatches.appendChild(s);
  });
}
function renderPatternSwatches(){
  patternSwatches.innerHTML='';
  STATE.patternDefaults.colors.forEach((c,idx)=>{
    const s = document.createElement('div'); s.className='swatch'; s.style.background=c;
    const x = document.createElement('div'); x.className='x'; x.textContent='✕';
    x.onclick = (ev)=>{ ev.stopPropagation(); STATE.patternDefaults.colors.splice(idx,1); renderPatternSwatches(); pushHistory(); };
    s.appendChild(x);
    s.onclick = ()=>{ const v = prompt('Edit color hex', c) || c; STATE.patternDefaults.colors[idx]=v; renderPatternSwatches(); pushHistory(); };
    patternSwatches.appendChild(s);
  });
}

/* ======= Interaction: drag to move selected text/image ======= */
let dragging = false, dragId = null, dragOffset = {x:0,y:0};
preview.onpointerdown = (ev)=>{
  const rect = preview.getBoundingClientRect();
  const x = (ev.clientX - rect.left)/rect.width * STATE.canvasSize;
  const y = (ev.clientY - rect.top)/rect.height * STATE.canvasSize;
  const sel = findSelected();
  if(sel && (sel.type==='text' || sel.type==='image')){
    dragging = true; dragId = sel.id;
    dragOffset.x = x - (sel.x||STATE.canvasSize/2); dragOffset.y = y - (sel.y||STATE.canvasSize/2);
    preview.setPointerCapture(ev.pointerId);
  }
};
preview.onpointermove = (ev)=>{
  if(!dragging) return;
  const rect = preview.getBoundingClientRect();
  const x = (ev.clientX - rect.left)/rect.width * STATE.canvasSize;
  const y = (ev.clientY - rect.top)/rect.height * STATE.canvasSize;
  const sel = STATE.layers.find(l=>l.id===dragId);
  if(sel){ sel.x = x - dragOffset.x; sel.y = y - dragOffset.y; render(); renderLayers(); }
};
preview.onpointerup = (ev)=>{
  if(dragging){
    dragging=false; dragId=null; pushHistory();
  }
};

/* ======= Other utilities ======= */
function fileImageInput(){ addImageInput.click(); }

/* ======= Randomize and Reset ======= */
function randomPalette(n=2){ const out=[]; for(let i=0;i<n;i++) out.push('#'+Math.floor(Math.random()*16777215).toString(16).padStart(6,'0')); return out; }
function randomizeDesign(){
  STATE.bg.mode = ['solid','linear','radial'][Math.floor(Math.random()*3)];
  STATE.bg.colors = randomPalette(1 + Math.floor(Math.random()*3));
  STATE.patternDefaults.colors = randomPalette(1 + Math.floor(Math.random()*3));
  STATE.patternDefaults.spacing = 10 + Math.floor(Math.random()*120);
  STATE.patternDefaults.size = 8 + Math.floor(Math.random()*120);
  STATE.layers = [];
  // add some patterns
  const n = 1 + Math.floor(Math.random()*3);
  for(let i=0;i<n;i++){
    const p = makePatternLayer({ patternType: PATTERNS[Math.floor(Math.random()*PATTERNS.length)]});
    p.params.colors = randomPalette(1 + Math.floor(Math.random()*3));
    p.params.size = 8 + Math.floor(Math.random()*120);
    p.params.spacing = 6 + Math.floor(Math.random()*80);
    p.opacity = Math.random();
    STATE.layers.push(p);
  }
  if(Math.random() > 0.5) STATE.layers.push(makeTextLayer('Design'));
  renderLayers(); pushHistory();
  render();
}
function resetDesign(){
  STATE.bg = { mode:'solid', colors:['#071728'], opacity:1 };
  STATE.layers = [];
  STATE.selected = null;
  STATE.patternDefaults = { thickness:2, spacing:40, size:24, rotation:0, colors:['#ffffff'], opacity:1 };
  renderBgSwatches(); renderPatternSwatches(); renderLayers(); pushHistory(); render();
}

/* ======= Export ======= */
function exportPNG(){
  // create high-res final canvas and export
  const W=STATE.canvasSize,H=STATE.canvasSize;
  const out = document.createElement('canvas'); out.width=W; out.height=H; const ctx = out.getContext('2d');
  drawBackground(ctx);
  for(const layer of STATE.layers){
    if(!layer.visible) continue;
    ctx.save();
    ctx.globalCompositeOperation = layer.blend || 'source-over';
    ctx.globalAlpha = layer.opacity ?? 1;
    ctx.filter = `blur(${STATE.canvasBlur}px)`;
    if(layer.type==='pattern') drawPattern(ctx, layer.params);
    else if(layer.type==='text') drawText(ctx, layer, false);
    else if(layer.type==='image') drawImage(ctx, layer);
    ctx.restore();
  }
  const link = document.createElement('a');
  link.href = out.toDataURL('image/png');
  link.download = 'deepseek-export-1080.png';
  link.click();
}

/* ======= Image utilities already defined above ======= */

/* ======= drawLayerThumbnail used earlier, updateSelectedThumb used earlier ======= */

/* ======= Layer helper: pick quick pattern ======= */
function pickPatternQuick(name){
  STATE.patternDefaults.patternType = name;
  // quick create preview
  render();
}

/* ======= Drawing helper convenience for text when thumbnail rendering (ctx used) ======= */
/* drawText and drawImage used previously handle both regular and thumbnail contexts */

/* ======= Setup initial UI and demo content ======= */
initUI();
renderLayers();

// add a demo pattern and text for initial view
if(STATE.layers.length===0){
  STATE.layers.push(makePatternLayer({patternType:'grid'}));
  STATE.layers.push(makeTextLayer('Hello'));
  STATE.selected = STATE.layers[STATE.layers.length-1].id;
  renderLayers(); syncSelectedUI(); pushHistory();
  render();
}

/* ======= Helpers to refresh UI when restoring from history or programmatic changes ======= */
function refreshUI(){
  renderBgSwatches(); renderPatternSwatches();
  renderLayers();
  syncSelectedUI();
}

/* ======= Expose for debug ======= */
window.STATE = STATE;
</script>
</body>
</html>
